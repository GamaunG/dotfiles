# vim: filetype=lf
## Previewers
#set previewer '~/.config/lf/previewer_noimages' 
set previewer '~/.config/lf/previewer' 
set cleaner '~/.config/lf/cleaner'
set sixel  #for sixel preview using chafa


## Settings
set hidden
set drawbox
set roundbox
set icons
set ignorecase
set incsearch
set smartcase
set mouse
set autoquit
set preserve 'mode:timestamps'
set shell bash
set ifs "\n"
set period 1
set scrolloff 10
set truncatepct 50
set dupfilefmt '%b(%n)%e'
set infotimefmtnew "02.01 15:04"
set infotimefmtold "02.01  2006"
set numberfmt "\033[2m"
set info time:size
#set info size:time

## Functions
#cmd open ${{
#    case $(file --mime-type "$f" -bL) in
#        text/*|application/json) $EDITOR "$f";;
#        *) cmd &$OPENER "$f" &>/dev/null;;
#    esac
#}}

cmd ExtractHere ${{
	for f in $fx; do
		if ! file -Lb --mime-type "$f" | grep -q '^application/.*'; then
			echo "$f isn't an archive"
			continue
		fi
		case "$f" in
			*.tar.gz | *.tgz) tar -xzf "$f" ;;
			*.tar.bz | *.tar.bz2 | *.tbz | *.tbz2) tar -xjf "$f" ;;
			*.tar.xz | *.txz) tar -xJf "$f" ;;
			*.tar.zst) tar --zstd -xf "$f" ;;
			*.tar) tar -xf "$f" ;;
			*.zip | *.jar) unzip "$f" ;;
			*.rar) unrar x "$f" ;;
			*.7z) 7z x "$f" ;;
			*) echo "Unsupported format: $f" ;;
		esac
	done
	lf -remote 'send reload'
}}

cmd ExtractToNewDir ${{
	for f in $fx; do
		if ! file -Lb --mime-type "$f" | grep -q '^application/.*'; then
			echo "$f isn't an archive"
			continue
		fi
		fn="$(basename "$f")"
		sfn=$(echo "$fn" | sed -E 's/(\.tar\.(gz|bz2?|xz|zst)|tgz|tbz2?|txz|zip|jar|rar|7z)$//')
		[ "$sfn" = "$fn" ] && sfn="${fn%%.*}"
		mkdir "$sfn" || continue
		(
			cd "$sfn" || exit 1
			case "$f" in
				*.tar.gz | *.tgz) tar -xzf "$f" ;;
				*.tar.bz | *.tar.bz2 | *.tbz | *.tbz2) tar -xjf "$f" ;;
				*.tar.xz | *.txz) tar -xJf "$f" ;;
				*.tar.zst) tar --zstd -xf "$f" ;;
				*.tar) tar -xf "$f" ;;
				*.zip | *.jar) unzip "$f" ;;
				*.rar) unrar x "$f" ;;
				*.7z) 7z x "$f" ;;
				*) echo "Unsupported format: $f"; exit 1 ;;
			esac
			) || {
				echo "Failed to extract $f"
			}
		[ -z "$(ls -A "$sfn")" ] && rmdir "$sfn"
	done
	lf -remote 'send reload'
	sel="$(printf '%s' "$sfn" | sed 's/\\/\\\\/g;s/"/\\"/g')"
	lf -remote "send $id select \"$sel\""
}}

cmd ArchiveTar %{{
	if [ -z "$fs" ] && [ -d "$f" ]; then
		dir=$(basename $f)
		tar -czvf $f.tar.gz "$dir"
		lf -remote "send $id select \"$f.tar.gz\""
	elif [ -n "$fs" ]; then
		[ -z "$1" ] && printf "Enter archive name (escape spaces): " && read answ || answ="$1"
		files=$(echo "$fx" | sed "s|^$PWD|.|g; s/\ /\\ /g")
		tar -czvf $answ.tar.gz $files
		lf -remote "send $id select \"$answ.tar.gz\""
	else
		echo "select directory or multiple files"
	fi
	lf -remote 'send reload'
}}

cmd ArchiveZip %{{
	if [ -z "$fs" ] && [ -d "$f" ]; then
		dir=$(basename $f)
		zip -r $f.zip "$dir"
		lf -remote "send $id select \"$f.zip\""
	elif [ -n "$fs" ]; then
		[ -z "$1" ] && printf "Enter archive name (escape spaces): " && read answ || answ="$1"
		files=$(echo "$fx" | sed "s|^$PWD|.|g; s/\ /\\ /g")
		zip -r $answ.zip $files
		lf -remote "send $id select \"$answ.zip\""
	else
		echo "select directory or multiple files"
	fi
	lf -remote 'send reload'
}}

cmd mkdir %{{
	IFS=" "; newdir="$*"
	mkdir -p -- "$newdir"
	sel="$(printf '%s' "$newdir" | sed 's/\\/\\\\/g;s/"/\\"/g')"
	lf -remote "send $id select \"$sel\""
}}

cmd touch %{{
	IFS=" "; file="$*"
	dir="${file%/*}"
	[ "$dir" != "$file" ] && mkdir -p "$dir"
	if [ ! -e "$file" ]; then
		case "${file##*.}" in
			sh)
				printf "#!/bin/bash\n " >>"$file"
				chmod +x "$file" ;;
			*) touch "$file" ;;
		esac
	fi
	sel="$(printf '%s' "$file" | sed 's/\\/\\\\/g;s/"/\\"/g')"
	lf -remote "send $id select \"$sel\""
}}

cmd chmod %{{
	[ -z "$1" ] && printf "chmod.. : " && read answ || answ="$1"
	for f in $fx; do
		chmod "$answ" "$f"
	done
	lf -remote 'send reload'
}}

cmd SymlinkCreate %{{
	for f in $fx; do
		ln -s "$f" "$f-link"
	done
	sel="$(printf '%s' "$f" | sed 's/\\/\\\\/g;s/"/\\"/g')"
	lf -remote "send $id select \"$sel-link\""
}}

cmd SymlinkConvertToRelative %{{
	for f in $fx; do
		if [ ! -L "$f" ]; then
			continue
		fi
		target="$(readlink -- "$f")"
		linkdir="$(dirname "$f")"
		reltarg="$(realpath --relative-to="$linkdir" "$target")"
		ln -sf "$reltarg" "$f"
	done
}}

cmd SymlinkRename %{{
	for f in $fx; do
		mv -i "$f" "${f%-link}"
	done
}}

cmd FollowLink %{{
	res="$(readlink -- "$f")"
	if [ -d "$res" ]; then
		cmd="cd"
	else
		cmd="select"
	fi
	sel="$(printf '%s' "$res" | sed 's/\\/\\\\/g;s/"/\\"/g')"
	lf -remote "send $id $cmd \"$sel\""
}}

cmd GoToTag ${{
	res="$(cat "$XDG_DATA_HOME/lf/tags" | fzf)"
	res="${res%:*}"
	if [ -f "$res" ]; then
		cmd="select"
	elif [ -d "$res" ]; then
		cmd="cd"
	else
		[ -z "$res" ] && exit
		echo "No such file or directory"
		echo "$res" | grep -q '#' && exit 1
		read -rp "Remove tag? (Y/n) " answ
		if [ "$answ" = "y" ] || [ -z "$answ" ]; then
			sed -i "\#${res}#d" "$XDG_DATA_HOME/lf/tags"
			exit
		fi
	fi
	sel="$(printf '%s' "$res" | sed 's/\\/\\\\/g;s/"/\\"/g')"
	lf -remote "send $id $cmd \"$sel\""
}}

cmd Bulkrename ${{
	tmp_old="$(mktemp)"
	tmp_new="$(mktemp)"
	tmp_pairs="$(mktemp)"
	[ -n "$fs" ] && fs=$(basename -a $fs) || fs=$(ls -A)
	echo "$fs" >"$tmp_old"
	echo "$fs" >"$tmp_new"

	$EDITOR "$tmp_new"

	[ "$(wc -l < "$tmp_old")" -eq "$(wc -l < "$tmp_new")" ] || { rm -f "$tmp_old" "$tmp_new" "$tmp_pairs"; exit 1; }
	paste "$tmp_old" "$tmp_new" >"$tmp_pairs"

	while IFS="$(printf '\t')" read -r src dst; do
		[ "$src" = "$dst" ] || mv -- "$src" "$src.renaming_$$"
	done <"$tmp_pairs"

	while IFS="$(printf '\t')" read -r src dst; do
		[ "$src" = "$dst" ] || mv -- "$src.renaming_$$" "$dst"
	done <"$tmp_pairs"

	rm -f "$tmp_old" "$tmp_new" "$tmp_pairs"
	lf -remote "send $id unselect"
}}

cmd fzf_jump ${{
	if command -v fd > /dev/null; then
		res="$(fd . -H -c always | fzf --ansi --bind "ctrl-/:toggle-preview,alt-k:up,alt-j:down,ctrl-o:execute:$EDITOR $DIR{1}" --preview-window '~4,+{2}+4/3,<80(up)' --preview "bat -fn $DIR{1}" --header="Jump to location")"
	else
		res="$(find . -maxdepth 6 | fzf --bind "ctrl-/:toggle-preview,alt-k:up,alt-j:down,ctrl-o:execute:$EDITOR $DIR{1}" --preview-window '~4,+{2}+4/3,<80(up)' --preview "cat $DIR{1}" --header="Jump to location")"
	fi
	if [ -n "$res" ]; then
		if [ -d "$res" ]; then
			cmd="cd"
		else
			cmd="select"
		fi
		res="$(printf '%s' "$res" | sed 's/\\/\\\\/g;s/"/\\"/g')"
		lf -remote "send $id $cmd \"$res\""
	fi
}}

# https://junegunn.github.io/fzf/tips/ripgrep-integration/
cmd fzf_ripgrep ${{
	(RELOAD='reload:rg --column --color=always --smart-case {q} || :'
	OPENER="$EDITOR {1} +{2}"
	ENTER="lf -remote 'send $id select {1}' ; $OPENER"
	fzf --disabled --ansi \
		--bind "start:$RELOAD" --bind "change:$RELOAD" \
		--bind "enter:become:$ENTER" \
		--bind "ctrl-o:execute:$OPENER" \
		--bind 'ctrl-/:toggle-preview,alt-k:up,alt-j:down' \
		--delimiter : \
		--preview 'bat --style=full --color=always --highlight-line {2} {1}' \
		--preview-window '~4,+{2}+4/3,<80(up)' \
		--query "$*")
}}

cmd GoToPath %{{
	[ -z "$1" ] && printf "go to path: " && read answ || answ="$1"
	res="$(eval echo "$answ" | sed -e "s|~|$HOME|")"
	if [ -f "$res" ]; then
		cmd="select"
	elif [ -d "$res" ]; then
		cmd="cd"
	fi
	[ -z "$cmd" ] && exit 1
	sel="$(printf '%s' "$res" | sed 's/\\/\\\\/g;s/"/\\"/g')"
	lf -remote "send $id $cmd \"$sel\""
}}

cmd git_branch ${{
	git branch | fzf | xargs git checkout
	pwd_shell=$(pwd | sed 's/\\/\\\\/g;s/"/\\"/g')
	lf -remote "send $id updir"
	lf -remote "send $id cd \"$pwd_shell\""
}}

cmd git_clone ${{
	[ "$1" = "git" ] && [ "$2" = "clone" ] && shift 2

	dir="${1##*/}"
	dir="${dir%%.git*}"
	git clone "$*" &&
		lf -remote "send $id cd \"$dir\""
}}

cmd DragAndDropSend %blobdrop $fx

cmd trash $trash-put $fx
cmd trash-restore $trash-restore 
cmd trash-empty %trash-empty

cmd CopyPath ${{
	if [ -n "$WAYLAND_DISPLAY" ]; then
		copy="wl-copy"
	elif [ -n "$TERMUX_VERSION" ]; then
		copy="termux-clipboard-set"
	else
		copy="xclip -selection clipboard"
	fi

	printf "%s" "$fx" | $copy
}}

cmd CopyName ${{
	if [ -n "$WAYLAND_DISPLAY" ]; then
		copy="wl-copy"
	elif [ -n "$TERMUX_VERSION" ]; then
		copy="termux-clipboard-set"
	else
		copy="xclip -selection clipboard"
	fi

	printf "%s" "$(basename -a $fx)" | $copy
}}

cmd CopyDirName ${{
	if [ -n "$WAYLAND_DISPLAY" ]; then
		copy="wl-copy"
	elif [ -n "$TERMUX_VERSION" ]; then
		copy="termux-clipboard-set"
	else
		copy="xclip -selection clipboard"
	fi

	printf "%s" "$(dirname -- $f)" | $copy
}}

cmd CopyFileContent ${{
	if [ -n "$WAYLAND_DISPLAY" ]; then
		copy="wl-copy"
	elif [ -n "$TERMUX_VERSION" ]; then
		copy="termux-clipboard-set"
	else
		copy="xclip -selection clipboard"
	fi

	if [ -z "$fs" ]; then
		$copy < "$f"
		exit
	fi
	(
		for f in $fs; do
			[ -d "$f" ] && continue
			echo "$(realpath --relative-to="$PWD" "$f"):"
			fn="${f##*/}"
			echo "\`\`\`${fn##*.}"
			cat "$f"
			echo "\`\`\`"
			echo ""
		done
	) | $copy
}}

cmd mtime_from_exif ${{
	exiftool -T -f -Directory -FileName -SubSecDateTimeOriginal -DateTimeOriginal -CreateDate $fx | \
	while IFS=$(printf '\t') read -r Directory FileName SubSecDateTimeOriginal DateTimeOriginal CreateDate; do

		if [ "$SubSecDateTimeOriginal" != "-" ]; then
			date="$SubSecDateTimeOriginal"
		elif [ "$DateTimeOriginal" != "-" ]; then
			date="$DateTimeOriginal"
		elif [ "$CreateDate" != "-" ]; then
			date="$CreateDate"
		else
			continue
		fi

		fpath="$Directory/$FileName"

		# fdate=$(echo "$date" | sed 's/:/-/; s/:/-/; s/Z$//')
		fdate=$(echo "$date" | sed 's/:/-/; s/:/-/')

		touch -m -d "$fdate" "$fpath"
	done
	lf -remote 'send reload'
}}

cmd rename_by_date ${{
	for f in $fx; do
		dir="$(dirname "$f")"
		fn="${f##*/}"

		if [ "$fn" = "${fn%.*}" ]; then
			ext=""
		else
			ext=".${fn##*.}"
			ext="${ext,,}"
		fi

		newFn="$(date -r "$f" +"%Y%m%d_%H%M%S")"
		newPath="$dir/$newFn$ext"

		if [ -e "$newPath" ] && [ "$newPath" != "$f" ]; then
			num=2
			while [ -e "$dir/$newFn-$num$ext" ]; do
				num=$((num + 1))
			done
			newPath="$dir/$newFn-$num$ext"
		fi

		# echo "$f -> $newPath"
		mv -n "$f" "$newPath"
	done
}}

cmd rename_lowercase ${{
	for f in $fx; do
		fn="${f##*/}"
		newFn=${fn,,}

		[ "$fn" = "$newFn" ] && continue
		dir=$(dirname "$f")

		newPath="$dir/$newFn"

		if [ -e "$newPath" ]; then
			echo "Skipping $newPath"
		else
			mv "$f" "$newPath"
		fi
	done
}}

cmd rename_lowercase_ext ${{
	for f in $fx; do
		fn="${f##*/}"
		[[ "$fn" != *.* ]] && continue

		dir=$(dirname "$f")
		basename="${fn%.*}"
		ext="${fn##*.}"

		newExt=${ext,,}

		[ "$ext" = "$newExt" ] && continue

		newPath="${dir}/${basename}.${newExt}"

		if [ -e "$newPath" ]; then
			echo "Skipping $newPath"
		else
			mv "$f" "$newPath"
		fi
	done
}}

# set globsearch # breaks search
cmd globSearchSelect &{{
	lf -remote "send $id :set globsearch" # breaks search
	lf -remote "send $id :glob-select $1; search; push $1<enter>"
	# lf -remote "send $id :set noglobsearch" # breaks search again
}}



## Bindings
# Sort
map sa set sortby atime
map sc set sortby ctime
map ss set sortby size
map st set sortby time
map sf set sortby ext
map sn set sortby natural
map sr set reverse!
map za set info time:size
map zc set info perm:user:group

map . set hidden!
map zP set previewer '~/.config/lf/previewer' 
map zp set previewer '~/.config/lf/previewer_noimages' 

# Actions
map ac chmod
map al SymlinkCreate
map aL SymlinkRename
map aC SymlinkConvertToRelative
map af FollowLink
map as DragAndDropSend
map adlf push $wget<space>-cq<space>--hsts-file=/.cache/wget-hsts<space>--show-progress<space>
map am mount
map au unmount

# Archivers
map aen ExtractToNewDir
map aeh ExtractHere
map aat ArchiveTar
map aaz	ArchiveZip

# Open
map e $$EDITOR "$f"
#map e $[ ! -d "$f" ] && $EDITOR "$f"
map se $sudoedit "$f"
map Xx $$f
map XX !$f

map <esc> :visual-discard; clear;
map <c-o> $$setsid gtk-launch org.gnome.Nautilus "$PWD" >/dev/null 2>&1 &
map <c-n> push :mkdir<space>
map <a-n> push $mkdir<space>
map <f-10> push $mkdir<space>
map <c-t> push :touch<space>
map <a-t> push $touch<space>
map <f-5> :set number!; set relativenumber!;
map <c-e> down
map <c-y> up
map <c-l> GoToPath
map gt GoToTag
map <c-v>  push :glob-select<space>
map gS push :globSearchSelect<space>*
map <delete> trash
map <s-delete> delete
map <enter> shell
map <c-q> quit
map TT trash
map Tr trash-restore
map Te trash-empty
map DD delete
map Dd MoveTo

map Yy CopyTo
map YY CopyPath
map Yc CopyFileContent
map Yn CopyName
map Yd CopyDirName

vmap u visual-unselect

# Rename
map A :rename; cmd-end # at the very end
map r :rename; cmd-end; cmd-delete-home # new name
map I :rename; cmd-home # at the very beginning
map i :rename # before extension
map c :rename; cmd-delete-home
#map a :rename; cmd-right # after extension
map B Bulkrename


# Git
map gb :git_branch
map gpl ${{clear; git pull || true; echo "press ENTER"; read ENTER}}
map gst ${{clear; git status; echo "press ENTER"; read ENTER}}
map glg ${{clear; git log --graph --parents --abbrev-commit --decorate --format=format:'%C(bold green)%h %p%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold yellow)(%ar)%C(reset)%C(auto)%d%C(reset)%n''%C(white)%s%C(reset) %C(dim white)- %an <%ae>%C(reset)' --all}}
map gcl push :git_clone<space>

map w

# Movement
source ~/.config/lf/shortcutrc
map C/ cd /
map J $lf -remote "send $id cd $(sed '/EDITOR/d; s/^[^"]*"\([^"]*\)".*/\1/' $HOME/.config/lf/shortcutrc | fzf --header='Jump to bookmark:')"
map <c-f> fzf_jump
map <c-g> fzf_ripgrep

## more stuff: https://github.com/gokcehan/lf/wiki/Integrations
